<<<<<<< HEAD
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on ⚽️</title>
    <link>http://mylofi.fun/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on ⚽️</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 07 Jul 2022 21:27:33 +0800</lastBuildDate>
    <atom:link href="http://mylofi.fun/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法之深度优先搜索与广度优先搜索</title>
      <link>http://mylofi.fun/posts/dfs-bfs/</link>
      <pubDate>Thu, 07 Jul 2022 21:27:33 +0800</pubDate>
      <guid>http://mylofi.fun/posts/dfs-bfs/</guid>
      <description>&lt;h3 class=&#34;heading&#34; id=&#34;深度优先搜索-dfs&#34;&gt;&#xA;  深度优先搜索 DFS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2-dfs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;深度优先搜索（Depth-First-Search）和广度优先搜索（Breadth-First-Search）都是一种用来遍历或者搜索树或图这种数据结构的算法。以树为例，深度优先搜索的过程会从根节点出发，尽可能深地遍历每个子节点，而且每个节点只能访问一次，是一个不断回溯的过程。&lt;/p&gt;&#xA;&lt;p&gt;实现方法大致如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先将根节点放入栈中&lt;/li&gt;&#xA;&lt;li&gt;从栈中取出第一个节点，并检验它是否为目标&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果找到目标，则结束搜索并返回结果&lt;/li&gt;&#xA;&lt;li&gt;否则将它某一个尚未检验过的直接子节点放入栈中&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重复步骤 2&lt;/li&gt;&#xA;&lt;li&gt;如果不存在未检测过的直接子节点&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将上一级节点放入栈中&lt;/li&gt;&#xA;&lt;li&gt;重复步骤 2&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重复步骤 4&lt;/li&gt;&#xA;&lt;li&gt;若栈为空，表示整张图都已检查过并且没有要查找的目标，结束搜索&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;另外需要我们了解的一种数据结构：栈。&lt;/p&gt;&#xA;&lt;p&gt;我们可以把盏比喻成一包手帕纸，每张纸巾都是按序一张一张放进去的，使用的时候是一张一张从最上边开始拿出来的。所以栈是一种后进先出（Last In First Out, LIFO）的数据结构。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;img-container&#34; &gt;&#xA;        &lt;img loading=&#34;lazy&#34; alt=&#34;&#34; src=&#34;http://mylofi.fun/images/dfs-bfs/dfs.png?width=50%22%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%22&#34; &gt;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;&lt;/figure&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;示例：通过 DFS 实现复制对象的复制&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;const&lt;/span&gt; copyDFS = &lt;span style=&#34;font-weight:bold;font-style:italic;text-decoration:underline&#34;&gt;function&lt;/span&gt;(obj) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;if&lt;/span&gt; (obj === &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;null&lt;/span&gt; || &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;typeof&lt;/span&gt; obj !== &lt;span style=&#34;color:#666;font-style:italic&#34;&gt;&amp;#34;object&amp;#34;&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;return&lt;/span&gt; obj;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;const&lt;/span&gt; copyObj = &lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;Array&lt;/span&gt;.isArray(obj) ? [] : {};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;const&lt;/span&gt; key &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;in&lt;/span&gt; obj) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    copyObj[key] = copyDFS(obj[key]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;return&lt;/span&gt; copyObj;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例：获取对象的所有键&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;const&lt;/span&gt; obj = { a: 1, b: 2, c: { d: 4, e: 5} }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic;text-decoration:underline&#34;&gt;function&lt;/span&gt; dfs(obj, keys = []) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;Object&lt;/span&gt;.entries(obj).forEach(([k, v]) =&amp;gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    keys.push(k)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;typeof&lt;/span&gt; v === &lt;span style=&#34;color:#666;font-style:italic&#34;&gt;&amp;#39;object&amp;#39;&lt;/span&gt;) dfs(v, keys)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  })&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;font-weight:bold;text-decoration:underline&#34;&gt;return&lt;/span&gt; keys&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#888;font-style:italic&#34;&gt;// [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#888;font-style:italic&#34;&gt;&lt;/span&gt;console.log(dfs(obj))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 class=&#34;heading&#34; id=&#34;广度优先搜索-bfs&#34;&gt;&#xA;  广度优先搜索 BFS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2-bfs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;广度优先搜索（Breadth-First-Search）也会沿着树的宽度进行遍历，通常用来解决两种问题：&lt;/p&gt;</description>
    </item>
  </channel>
=======
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>算法 - 标签 - Mylo</title>
        <link>http://flyingmylo.com/tags/%E7%AE%97%E6%B3%95/</link>
        <description>算法 - 标签 - Mylo</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 07 Jul 2022 21:27:33 &#43;0800</lastBuildDate><atom:link href="http://flyingmylo.com/tags/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml" /><item>
    <title>算法之深度优先搜索与广度优先搜索</title>
    <link>http://flyingmylo.com/posts/dfs-bfs/</link>
    <pubDate>Thu, 07 Jul 2022 21:27:33 &#43;0800</pubDate>
    <author>Mylo</author>
    <guid>http://flyingmylo.com/posts/dfs-bfs/</guid>
    <description><![CDATA[深度优先搜索 DFS 深度优先搜索（Depth-First-Search）和广度优先搜索（Breadth-First-Search）都是一种用来遍历或者搜索树或图这种数据结构的算法。以树为例，深度优先搜索的过程会从根节点出发，尽可能深地遍历每个子节点，而且每个节点只能访问一次，是一个不断回溯的过程。
实现方法大致如下：
 首先将根节点放入栈中 从栈中取出第一个节点，并检验它是否为目标  如果找到目标，则结束搜索并返回结果 否则将它某一个尚未检验过的直接子节点放入栈中   重复步骤 2 如果不存在未检测过的直接子节点  将上一级节点放入栈中 重复步骤 2   重复步骤 4 若栈为空，表示整张图都已检查过并且没有要查找的目标，结束搜索  另外需要我们了解的一种数据结构：栈。
我们可以把盏比喻成一包手帕纸，每张纸巾都是按序一张一张放进去的，使用的时候是一张一张从最上边开始拿出来的。所以栈是一种后进先出（Last In First Out, LIFO）的数据结构。
示例：通过 DFS 实现复制对象的复制
const copyDFS = function(obj) { if (obj === null || typeof obj !== &#34;object&#34;) { return obj; } const copyObj = Array.isArray(obj) ? [] : {}; for (const key in obj) { copyObj[key] = copyDFS(obj[key]); } return copyObj; } 示例：获取对象的所有键]]></description>
</item>
</channel>
>>>>>>> 70fc96867e523bbae0b684b0084ffcf7670583c3
</rss>
